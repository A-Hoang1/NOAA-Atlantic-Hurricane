---
title: "Final Project"
author: "Andrew & Ben"
output: html_document
date: "2024-11-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
 fig.align = "center")
 #message = F,
 #warning = F)

# Loading in the needed packages
pacman::p_load(tidyverse, skimr, GGally, regclass, broom, caTools, FNN, 
               htmltools, ggdist, rpart, rpart.plot)

# Changing default themes
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5),
 plot.subtitle = element_text(hjust = 0.5))

# Changing the default choice for how many decimal places are displayed
options(digits = 4)
```

# Introduction
Airbnb is a popular company that connects people looking for accommodations with hosts who offer lodging options. The company was founded in 2008 and allows hosts to list their own properties, which can range from a single room to an entire house) for short-term rentals. Even though Airbnb has fares that it sets, most of the price comes down to what the host want to set the price at. This inspired us to determine if the number of people that can be accommodated in an Airbnb property affects the price of the listing. If this is not true, we wanted to explore if there are any other variables that affect the price more than how many people it can accommodate. More information on the additional types of fees that Airbnb charges can be found at: <https://www.airbnb.com/help/article/125>. The data was retrieved from Kaggle user Oscar Batiz the link is the following: <https://www.kaggle.com/datasets/oscarbatiz/los-angeles-airbnb-listings>.

## Getting the data
The code chunk below will load the data of Airbnb listings as of 04 of September 2024. We'll start by cleaning the data and removing any columns that do not have information. 
```{r Getting the data}
# Reads in the file
listings <- read.csv("listings.csv")

# Clean up the data
listings_clean <- 
  listings |> 
  # Selects the columns that we are interested in exploring
  dplyr::select(price, room_type:beds) |>
  # Removes listings without a price
  filter(!is.na(price))

# Displays clean data
str(listings_clean)
```

The variables we are going to use are: 

1) **price**: The price of the AirBnb in US dollars. 

2) **room_type**: Is used to describe the type of listing (i.e: if the listings is a "Entire home/apt, "Private Room", "Shared Room" or "Hotel Room")

3) **accommodates**: Is the number of people that the listing can accommodate

4) **bathrooms**: Is the number of bathrooms the listings has

5) **bedrooms**: Is the number of bedrooms the listing has

6) **beds**: Is the number of beds the listing has



## Preparing the Data
```{r Preparing the Data}
# Displays a quartile summary for the data
summary(listings_clean$price)
```

There seems to be some outliers in this data, particularly with the maximum price of $56,425 which is much higher than the third quartile of 260. This is causing the mean (289) to be notably higher than the median (155) indicating a skewed distribution.

Lets try to fix this by removing some outliers:
```{r Fixing outliers}
# Calculate the 5th and 95th percentiles for the price variable
lower_5th <- quantile(listings_clean$price, 0.05, na.rm = TRUE)
upper_95th <- quantile(listings_clean$price, 0.95, na.rm = TRUE)

# Filters the dataset to keep only the prices within the 5th & 95th percentiles
listings_clean2 <- 
  listings_clean |> 
  filter(price >= lower_5th & price <= upper_95th)

# Checks the summary of the new dataset without extreme outliers
summary(listings_clean2$price)
```

Looking at our data now, there seems to be fewer outliers now since we have taken out the top 95th and bottom 5th percentiles to get rid of extreme cases. These could be either fake listings or listings that are very rare so we do not want to include these in our models further on. Our median is now closer to our mean and our max and min are not as far away from our mean as well.

Lets have a look at our histogram of price:
```{r Histogram Price}
# Creates a plot of price
ggplot(data = listings_clean2, 
       mapping = aes(x = price)) +
  
  # Plots the histogram
  geom_histogram(bins = 40, 
                 fill = "steelblue", 
                 color = "black") +
  
  # Changes titles
  labs(title = "Distribution of Airbnb Prices",
       x = "Price", 
       y = "Frequency") + 
  
  # Adds currency to the x-axis labels
  scale_x_continuous(label = scales::label_currency()) +

  scale_y_continuous(expand = c(0,0),
                     limits = c(0, 3800))
```

Looking at our histogram there still seems to be a noticeble right-skew, with a concentration of values between approximately 60 and 300. This suggests, that while most listings are priced lower, a few high-priced outliers are influencing the ditribution, by pulling the mean upwards. 

Lets try applying a log transformation to the price to see if this helps.
```{r}
# Applies log10 transformation to the listing
listings_clean2$log10_price <- log10(listings_clean2$price)

```

Now that we have applied a log10 transformation to our data let's have a look to see if the data follows a more normal distribution.

```{r Log10 Price}
# Creates a plot of price
ggplot(data = listings_clean2, 
       mapping = aes(x = price)) +
  
  # Plots a histogram
  geom_histogram(bins = 40, 
                 fill = "steelblue", 
                 color = "black") +
  
  # Changes the labels
  labs(title = "Distribution of Airbnb Prices After Log10 Transformation",
       x = "Price", 
       y = "Frequency") + 
  
  # Adds a log10 transformation and currency to label on x-axis
  scale_x_continuous(label = scales::label_currency(),
                     trans = scales::log10_trans()) + 
  scale_y_continuous(limits = c(0, 2200),
                     expand = c(0,0))

```

Now that we have applied the transformation our data looks more normal and it is not as skewed.

Lets explore the room types variable to see if this will help predict the price of the Airbnbs.

```{r}

# Create a ggplot with custom mappings and data
ggplot(data = listings_clean2, 
       mapping = aes(
         x = room_type,    # Room type on the x-axis
         y = price,        # Price on the y-axis
         fill = room_type  # Fill color by room type
       )) + 
  
  coord_flip() +  # Flips the axes for horizontal layout
  
  # Customizes title, subtitle, and axis labels
  labs(
    title = "Distribution of Airbnb Prices by Room Type",  # Main plot title
    subtitle = "<span style='color:#6A5ACD;'>Shared rooms</span>,
               <span style='color:#159090;'>private rooms</span>,
               <span style='color:#FF8C00;'>entire homes/ apt</span> &
              <span style='color:#800080;'>hotel rooms</span>
              price distributions in US Dollars",  # Colored subtitle using HTML
    x = NULL,  # Remove x-axis label
    y = NULL   # Remove y-axis label
  ) +
  
  # Plots distribution of values
  ggdist::stat_halfeye(
    adjust = .8,           # Adjusts the smoothness of the density plot
    width = .7,            # Width of the distribution plot
    .width = 0,            # No additional width for confidence intervals
    justification = -0.45  # Adjusts the positioning of the plots
  ) + 
  
  # Add boxplot
  geom_boxplot(
    width = .4,            # Sets boxplot width
    outlier.shape = NA     # Remove outliers from the boxplot
  ) +
  
  # Add text annotation for the median
  stat_summary(
    geom = "text",         # Use text for annotation
    fun = "median",        # Calculate median for each room type
    # Displays rounded mean in the label
    aes(label = paste0("median = $",round(after_stat(y), 0)),  
        color = stage(
          room_type, after_scale = colorspace::lighten(
            color, .8, space = "HLS"))), # Lightens color based on room type
    fontface = "bold",                   # Makes the label bold
    size = 3,                            # Sets label text size
    vjust = -3.5                          # Adjust vertical position of label
  ) +
  
 # Customize colors for room_type
  scale_fill_manual(values = c("Entire home/apt" = "#FF8C00",
                               "Private room" = "#159090",
                               "Shared room" = "#6A5ACD",
                               "Hotel room" = "#800080")) +
  
  # Customize y-axis with log transformation and currency formatting
  scale_y_continuous(label = scales::label_currency(), # Formats as currency
                     trans = scales::log10_trans(),  # Log 10 transformation
                     expand = c(0, 0.03),            # Expand y-axis slightly
                     breaks = c(0, 50, 100, 200, 400, 800)) + # Sets spacing
  
  scale_x_discrete(expand = c(0.15, 0.15), # Expand x-axis for better spacing
                   limits = c("Hotel room", "Entire home/apt", "Private room",
                              "Shared room")) + # Changes order of room types
  
  # Customizes plot theme
  theme(
    legend.position = "none",                 # Removes legend
    axis.text.y = element_blank(),            # Removes y-axis labels
    axis.ticks = element_blank(),             # Removes axis ticks
    panel.grid.major.y = element_blank(),     # Removes major grid lines
    panel.grid.minor = element_blank(),       # Removes minor grid lines
    panel.border = element_blank(),           # Removes border around the plot
    plot.subtitle = ggtext::element_markdown(), # Render subtitle as markdown 
    plot.title = element_text(face = "bold")  # Makes the title bold
  )
```

The graph illustrate that shared rooms and private rooms are the most budget-friendly options of AirBnbs, while entire homes/apartments and hotel rooms may be for higher-budgets travelers.

```{r}
# Creates the bar chart with count labels on top of each bar
ggplot(
  data = listings_clean2,
  mapping = aes(
    x = room_type,
    fill = room_type)
) +
  
  # Changes title and subtitle and remove axis labels
  labs(title = "AirBnb Listings Breakdown",
       subtitle = "The number of listings for each type of Airbnb",
       x = NULL,
       y = NULL) +
  
  # Plots bar chart
  geom_bar(stat = "count") +
  
  # Adds count labels on top of the bars
  geom_text(stat = 'count', aes(label = after_stat(count)), vjust = -0.5) +  
  
  # Changes order of room types
  scale_x_discrete(
    limits = c("Hotel room", "Shared room","Private room",
               "Entire home/apt")
  ) + 
  
  # Changes theme to minimal
  theme_minimal() + 
  
  # Adjust some 
  theme(
    legend.position = "none",
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

```

Since the price range for entire homes/apartments is comparable to hotels and there are only 77 listings for hotel rooms, and the price range for private and shared rooms (only 94 listings of shared room type) is similar, it makes sense to group these categories into two broader groups for analysis. This approach simplifies the data by grouping similar categories, creating one group for “Rooms” (private and shared rooms), which will be assigned a "0", and another for “Hotels Rooms/Entire Apartments/Homes”, which will be assigned a 1. This categorization will help us generalize insights into pricing trends across different accommodations.

Lets go ahead and group these types of room type listings.
```{r Grouping Room Types}
listings_clean2 <- 
  listings_clean2 |> 
  mutate(
    # Changes "Entire home/apt" and "Hotel Room" to "1"
    # Changes "Private room" and "Shared room" to "0"
    room_type = if_else(
      room_type == "Entire home/apt" | room_type == "Hotel Room", 1, 0
    )
  )
```

Lets have a look at the boxplot for the new categorization of listings for predicting price.

```{r}

# Create a ggplot with custom mappings and data
ggplot(
  data = listings_clean2, 
  mapping = aes(
    x = factor(room_type),    # Room type on the x-axis
    y = price,        # Price on the y-axis
    fill = factor(room_type)  # Fill color by room type
  )) + 
  
  coord_flip() +  # Flips the axes for horizontal layout
  
  # Customizes title, subtitle, and axis labels
  labs(
    title = "Distribution of Airbnb Prices by Room Type",  # Main plot title
    subtitle = "<span style='color:#FF8C00;'>Private or shared rooms</span> & 
    <span style='color:#159090;'>entire homes, apt & hotel rooms</span> price
    distributions in US Dollars",  # Colored subtitle using HTML
    x = NULL,  # Remove x-axis label
    y = NULL   # Remove y-axis label
  ) +
  
  # Plots distribution of values
  ggdist::stat_halfeye(
    adjust = .8,           # Adjusts the smoothness of the density plot
    width = .7,            # Width of the distribution plot
    .width = 0,            # No additional width for confidence intervals
    justification = -0.45  # Adjusts the positioning of the plots
  ) + 
  
  # Adds boxplot
  geom_boxplot(
    width = .4,            # Sets boxplot width
    outlier.shape = NA     # Remove outliers from the boxplot
  ) +
  
  # Adds text annotation for the median
  stat_summary(
    geom = "text",         # Uses text for annotation
    fun = "median",        # Calculates median for each room type
    # Displays rounded mean in the label
    aes(label = paste0("median = $", round(after_stat(y), 2)),  
        color = stage(
          room_type, after_scale = colorspace::lighten(
            color, .9, space = "HLS"))), # Lightens color based on room type
    fontface = "bold",                   # Makes the label bold
    size = 4,                            # Sets label text size
    vjust = -5                           # Adjust vertical position of label
  ) +
  
  # Set custom fill colors for room types
  scale_fill_manual(values = c("0" = "#FF8C00", "1" = "#159090")) +

  # Customize y-axis with log transformation and currency formatting
  scale_y_continuous(label = scales::label_currency(), # Formats as currency
                     trans = scales::log10_trans(),  # Log 10 transformation
                     expand = c(0, 0.03),            # Expand y-axis slightly
                     breaks = c(0, 50, 100, 200, 400, 800)) + # Sets spacing
  
  scale_x_discrete(expand = c(0.3, 0.03)) +  # Expand x-axis for better spacing
  
  # Customizes plot theme
  theme(
    legend.position = "none",                 # Removes legend
    axis.text.y = element_blank(),            # Removes y-axis labels
    axis.ticks = element_blank(),             # Removes axis ticks
    panel.grid.major.y = element_blank(),     # Removes major grid lines
    panel.grid.minor = element_blank(),       # Removes minor grid lines
    panel.border = element_blank(),           # Removes border around the plot
    plot.subtitle = ggtext::element_markdown(), # Render subtitle as markdown 
    plot.title = element_text(face = "bold")  # Makes the title bold
  )

```

Looking at the Airbnb room type boxplots the presence of outliers in the higher range for entire homes indicates while most of the listings in this category are within are certain price range, there seems to be a few luxury listings contributing significantly to inflating the overall price average. The median listing for "Entire home/apt" or "Hotel rooms" seems to be higher than "Private rooms" or "Shared rooms". Additionally, the distribution of price for entire homes/apt or hotel rooms seems to be much higher than for private or shared rooms.


Now that we changed this variable we will now longer need the large listings dataset so we can remove it. 
```{r}
# Removes the listings data set since it is large and not used again
rm(listings)
```

Lets explore some of the other predictors before we start building some of our models.
```{r}
listings_clean2 |> 
  dplyr::select(where(is.numeric)) |> 
  drop_na() |> 
  ggcorr(
    low = "tomato",
    mid = "white",
    high = "steelblue",
    label = T,
    label_round = 2,
    angle = -25,
    hjust = 1
  )

```

There seems to be some potential multicollinearity, especially among bedrooms, beds, bathrooms and accommodates. Using all these variables could potentially lead to misinterpretation of our predictors and could also inflate the standard errors by making it difficult to assess the significance of individual predictors in the model.

Lets have a look at the variables with the highest association with listings price.
```{r}
# Calculating the 5 number summary for each predictor
listings_clean2 |> 
  pivot_longer(
    cols = c(accommodates, bedrooms, bathrooms, beds), 
    names_to = "variable",
    values_to = "values"
  ) |> 
  summarize(
    min = min(values, na.rm = T),
    Q1 = quantile(values, 0.25, na.rm = T),
    median = median(values, na.rm = T),
    Q3 = quantile(values, 0.75, na.rm = T),
    max = max(values, na.rm = T),
    mean = round(mean(values, na.rm = T),2),
    .by = variable
  ) |> 
  gt::gt()

```

The maximum value of 50 is significantly larger than the rest of the data for bedrooms, bathrooms and beds. These extreme value of 50 suggests the presence of some potential outliers in the data. These could be from potential fake listings on Airbnb.

Lets go ahead and remove the highest and lowest percentile of bedrooms, beds & bathrooms
```{r}
# Calculate the 1st and 99th percentiles for the bedrooms variable
lower_per_bed <- quantile(listings_clean2$bedrooms, 0.01, na.rm = TRUE)
upper_bed_99th <- quantile(listings_clean2$bedrooms, 0.99, na.rm = TRUE)

# Filter the dataset to keep only the listings within the percentiles for bedrooms
listings_clean3 <- listings_clean2 |> 
  filter(bedrooms >= lower_per_bed & bedrooms <= upper_bed_99th)

# Calculate the 1st and 99th percentiles for the bathrooms variable
lower_per_bath <- quantile(listings_clean3$bathrooms, 0.01, na.rm = TRUE)
upper_bath_99th <- quantile(listings_clean3$bathrooms, 0.99, na.rm = TRUE)

# Filter the dataset to keep only the listings within the percentiles for bathrooms
listings_clean3 <- listings_clean3 |> 
  filter(bathrooms >= lower_per_bath & bathrooms <= upper_bath_99th)

# Calculate the 1st and 99th percentiles for the beds variable
lower_per_beds <- quantile(listings_clean3$beds, 0.01, na.rm = TRUE)
upper_beds_99th <- quantile(listings_clean3$beds, 0.99, na.rm = TRUE)

# Filter the dataset to keep only the listings within the percentiles for beds
listings_clean3 <- listings_clean3 |> 
  filter(beds >= lower_per_beds & beds <= upper_beds_99th)

# Check the summary of the new dataset without extreme outliers
listings_clean3 |> 
  pivot_longer(
    cols = c(accommodates, bedrooms, bathrooms, beds), 
    names_to = "variable",
    values_to = "values"
  ) |> 
  summarize(
    min = min(values, na.rm = T),
    Q1 = quantile(values, 0.25, na.rm = T),
    median = median(values, na.rm = T),
    Q3 = quantile(values, 0.75, na.rm = T),
    max = max(values, na.rm = T),
    mean = round(mean(values, na.rm = T),2),
    .by = variable
  ) |> 
  gt::gt()

```

Now the furthest percentile outliers have been removed. Lets continue exploring our predictors.

Lets have a look at accomodates, bedrooms, bathrooms and beds predictors to see if they have any relationship with price.

```{r}

listings_clean3 |> 
  # Removes rows with NA values
  filter(!is.na(accommodates) & !is.na(bedrooms) & !is.na(bathrooms) &
           !is.na(beds)) |> 
  
  # Combines multiple predictors into a single column for easier visualization
  pivot_longer(
    cols = c(accommodates, bedrooms, bathrooms, beds), 
    names_to = "variable",
    values_to = "values"
  ) |> 
  
  # Maps the predictors' values to the x-axis and price to the y-axis
  ggplot(
    mapping = aes(
      x = factor(values),
      y = price,
      fill = variable)) +
  
  # Adds a title and axis labels for clarity
  labs(
    title = "Price Distribution by Predictive Variables",
    subtitle = "Exploring accommodates, bedrooms, bathrooms & beds predictors.",
    x = NULL,
    y = NULL
  ) +
  
  # Adds a boxplot to display the distribution of price for each predictor
  geom_boxplot(
    outlier.shape = NA # Removes outliers to avoid clutter
  ) +
  
  # Adjusts the y-axis to use a log10 scale for better visualization of price distribution
  scale_y_continuous(
    labels = scales::label_currency(), # Formats y-axis labels as currency
    trans = scales::log10_trans(),     # Applies log transformation
    breaks = c(0, 66, 125, 250, 500, 1000) # Customizes axis breaks
  ) +
  
  # Creates individual panels for each predictor variable
  facet_wrap(
    facet = ~ variable, 
    nrow = 2,                 # Arranges panels in two rows
    scales = "free_x",        # Allows x-axis scaling to vary between panels
    labeller = as_labeller(c( # Customizes labels for each panel
      accommodates = "Accommodates", 
      bedrooms = "Bedrooms",
      bathrooms = "Bathrooms",
      beds = "Beds"
    ))
  ) +
  
  # Customizes the fill colors for each variable to improve aesthetics
  scale_fill_manual(
    values = c(
      "accommodates" = "#66c2a5",
      "bedrooms" = "#fc8d62",
      "bathrooms" = "#8da0cb",
      "beds" = "#e78ac3"
    )
  ) +
  
  # Applies a theme and customizes specific theme elements
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"), # Sets the title in bold
    legend.position = "none"  # Removes the legend for simplicity
  )

```

Prices seem to increase as the number of people the listing accommodates rises, showing a positive and somewhat linear trend. Listings with more bathrooms also seem to have higher prices, also showing a positive and somewhat linear trend. In terms of bedrooms, as the number of bedrooms increases to up to around 6, so does the price. However, beyond 6 bedrooms the relationship is less clear, likely due to fewer listings with a high number of bedrooms. For beds, the price generally increases with the number of beds, but the relationship also flattens a bit and become less predictable once the listings have more than 5 beds.

Now that we know this lets start working on some machine learning models with our data.

# Machine Learning Techniques
Lets start by constructing some Linear Models to determine price.
```{r}
listings_clean3 <- listings_clean3 |> drop_na()
# Simple model predicting price based on accommodates only
price_lm1 <- lm(
  formula = price ~ accommodates,
  data = listings_clean3
)

# Simple model predicting price based on bedrooms only
price_lm2 <- lm(
  formula = price ~ bedrooms,
  data = listings_clean3
)

# Adds room_type to the predictors
price_lm3 <- lm(
  formula = price ~ accommodates + room_type,
  data = listings_clean3
)

# Predicts price using bedrooms and room_type
price_lm4 <- lm(
  formula = price ~ bedrooms + room_type,
  data = listings_clean3
)

# Combines bedrooms, room_type, and accommodates as predictors
price_lm5 <- lm(
  formula = price ~ bedrooms + room_type + accommodates,
  data = listings_clean3
)

# Uses bedrooms, room_type, and bathrooms to predict price
price_lm6 <- lm(
  formula = price ~ bedrooms + room_type + bathrooms,
  data = listings_clean3
)

# Adds accommodates to price_lm6 predictors
price_lm7 <- lm(
  formula = price ~ bedrooms + room_type + accommodates + bathrooms,
  data = listings_clean3
)
```

Now that we have built some models lets analyze which model is the best at predicting Airbnb prices.

Analyzing our Models
```{r}
bind_rows(
  .id = "model",
  "price_lm1" = glance(price_lm1),
  "price_lm2" = glance(price_lm2),
  "price_lm3" = glance(price_lm3),
  "price_lm4" = glance(price_lm4),
  "price_lm5" = glance(price_lm5),
  "price_lm6" = glance(price_lm6),
  "price_lm7" = glance(price_lm7)
) |> 
  dplyr::select(model, n_predictors = df, r.squared, sigma) |> 
  mutate(r.squared = round(r.squared, 3),
         sigma = round(sigma, 0),
         MAE = round(c(
           mean(abs(price_lm1$residuals)),
           mean(abs(price_lm2$residuals)),
           mean(abs(price_lm3$residuals)),
           mean(abs(price_lm4$residuals)),
           mean(abs(price_lm5$residuals)),
           mean(abs(price_lm6$residuals)),
           mean(abs(price_lm7$residuals))), 3)) |> 
  gt::gt()

```

Overall, price_lm6 appears to be the best trade-off between simplicity and performance. It has the second-highest R-squared (0.423), the lowest sigma (104), and uses only three predictors (bedrooms, room_type, bathrooms), making it simpler and less prone to overfitting compared to price_lm7. The sigma still seems to be high at 104. This number means that typically, the model’s predictions of Airbnb prices are off by approximately \$104 from the actual prices which is quite high. The average prediction error looking at MAE is \$69.47.

Lets have a further look if these predictors will be a problem with our model by calculating the variance inflation factor (VIF). 
```{r}
regclass::VIF(price_lm6)
```

Since our VIF values are below 5, it indicates that multicollinearity is not severe.


```{r}
# Predictions for the test dataset using the full data frame as newdata
price7 <- predict(object = price_lm7, newdata = listings_clean3)
price6 <- predict(object = price_lm6, newdata = listings_clean3)
price5 <- predict(object = price_lm5, newdata = listings_clean3)
price4 <- predict(object = price_lm4, newdata = listings_clean3)
price3 <- predict(object = price_lm3, newdata = listings_clean3)
price2 <- predict(object = price_lm2, newdata = listings_clean3)
price1 <- predict(object = price_lm1, newdata = listings_clean3)

# Create a data frame with actual prices and predictions from all models
price_pred <- data.frame(
  actual_price = listings_clean3$price,
  price7 = price7,
  price6 = price6,
  price5 = price5,
  price4 = price4,
  price3 = price3,
  price2 = price2,
  price1 = price1
)

head(price_pred)

```
It seems the predictions are a bit off, let's try and graph the residual density plot to better visualize the model's performance.

```{r}
# Calculates residuals and additional information
augmented_data <- augment_columns(
  x = price_lm6,            # The linear model
  data = listings_clean3    # The original dataset
)

# Creates a density plot of residuals
ggplot(
  data = augmented_data,    
  mapping = aes(
    x = .resid,             # Maps residuals to the x-axis
    fill = "tomato"         # Changes fill color
  )
) +
  geom_density(alpha = 0.5) +  # Adds density plot with 50% transparency
  
  # Adds a vertical dashed line for the median residual
  geom_vline(
    xintercept = median(augmented_data$.resid), # Computes median of residuals
    linetype = "dashed"                         # Uses a dashed line
  ) +  
    
  # Annotates the plot with the median value
  annotate(
    geom = "text",                        # Adds a text annotation
    x = 120,                              # Sets the x-coordinate for the text
    y = 0.0075,                           # Sets the y-coordinate for the text
    # Displays median value
    label = paste("Median =", round(median(augmented_data$.resid), 2))  
  ) +
  
  # Formats the x-axis labels as currency
  scale_x_continuous(labels = scales::label_currency()) + 
  
  # Changes theme to minimal
  theme_minimal() +  
  
  # Adds labels and title to the plot
  labs(
    title = "Density Plot of Residuals",  # Sets the title
    x = "Residuals",                      # Labels for the x-axis
    y = "Density"                         # Labels for the y-axis
  ) + 
  
  # Customizes the theme
  theme(
    plot.title = element_text(face = "bold"),  # Makes the title bold
    legend.position = "none"                   # Removes the legend
  )

```

The residuals are centered around the median of approximately, -19.62, which indicates a slight bias in predictors. The suggests that on average, the model tends to underpredict the actual prices by \$19.62. Additionally, the residuals have a wide range, from approximately -300 to almost 750. This suggests that while most predictions are somewhat close to the actual values, there are some instances where the model significantly overpredicts the prices. This right-skewed distribution, suggests that the model occasionally predicts prices that are much higher than the actual values. This could be due to several outliers in the data that disproportionately influence the model.

```{r}
# Calculates the residuals and additional information
augment_columns(
  x = price_lm6,            # The linear model
  data = listings_clean3    # The original dataset
) |> 
  # Selects the columns we want
  dplyr::select(bedrooms, bathrooms, .resid) |> 
  
  # Pivots the predictors into one column
  pivot_longer(
    cols = -.resid,          # Selects all columns except residuals
    names_to = "predictor",  # Names column for predictor names
    values_to = "value"      # Names column for predictor values
  ) |> 

  # Groups by predictor and value, then calculates summary statistics
  summarise(
    mean_resid = mean(.resid),    # Calculates mean residuals for each group
    sd_resid = sd(.resid),        # Calculates standard deviation of residuals
    n = n(),                      # Counts number of observations per group
    .by = c(predictor, value)     # Performs these calculations by group
  ) |> 
  
  # Adds additional computed columns
  mutate(
    se_resid = sd_resid / sqrt(n),             # Calculates standard error
    lower_ci = mean_resid - 1.96 * se_resid,   # Lower 95% confidence interval
    upper_ci = mean_resid + 1.96 * se_resid    # Upper 95% confidence interval
  ) |> 
  
  # Plots the aggregated data
  ggplot(
    mapping = aes(
      x = value,                # Predictors value on x-axis
      y = mean_resid,           # Mean residual on y-axis
      color = predictor         # Changes color for each predictor
    )
  ) +
  
  # Adds points for mean residuals
  geom_point() +
  
  # Adds error bars for 95% confidence intervals
  geom_errorbar(
    aes(ymin = lower_ci, ymax = upper_ci),      # Maps CI bounds to error bars
    width = 0.2                                 # Sets width of error bars
  ) +
  
  # Create separate panels for each predictor
  facet_wrap(
    facet = ~predictor,                     # Creates panels based on predictor
    labeller = as_labeller(c(               # Customizes facet labels
      bedrooms = "Bedrooms",                # Labels for 'bedrooms' predictor
      bathrooms = "Bathrooms"               # Labels for 'bathrooms' predictor
    ))
  ) +     

  # Adds labels and titles to the plot
  labs(
    title = "Mean Residuals with Error Bars by Predictor",  # Plots title
    x = NULL,                                           # Removes x-axis labels
    y = "Mean Residuals",                               # Labels y-axis
    caption = "Error bars represent 95% confidence intervals." # Adds captions
  ) +
  
  # Applies theme settings
  theme(
    title = element_text(face = "bold"),      # Bolds title text
    legend.position = "none"                  # Removes legend
  )

```

The mean residuals fluctuate significantly as the number of bathrooms increases. There seems to be greater variability in the model's predictions for properties with more bathrooms. The mean residuals for bedrooms seem to be pretty stable across the range. There is no clear pattern or bias in the residuals across the ranges. 

Since our linear models were not great at predicting the price of the listings lets go ahead and try some other machine learning methods. Given the size of the dataset (32,000 cases), a regression tree is preferable to kNN regression because kNN will take much longer to run. Additionally, the lack of interpretability makes it less suitable for a dataset of this size. Finally, a regression tree may be more appropriate so we can incorporate both numeric and categorical variables. 

Let's create the full tree with our predictors and find the prune cutoff.
```{r}
# set seet for reproducibility
RNGversion("4.1.0")
set.seed(1234)

# full regression tree with bedrooms, bathrooms, and room_type
airbnb_full <-
 rpart(
   formula = log10_price ~ bedrooms + room_type + bathrooms,
   data = listings_clean3,
   method = "anova",  # indicates to make a reg tree
   # stop the prepruning criteria
   minsplit = 2,
   minbucket = 1,
   cp = 0
 )

# find xerror cutoff
airbnb_full$cptable |>
 data.frame() |>
 # find row with smallest xerror
 slice_min(xerror, n = 1, with_ties = F) |>
 # using mutate xerror + xstd = xerror_cutoff
 mutate(xerror_cutoff = xerror + xstd) |>
 # save the xerror cutoff value as xcutoff
 pull(xerror_cutoff) ->
 xcutoff
 
# find the cp value to prune the tree
airbnb_full$cptable |>
 data.frame() |>
 # use filter to pick the rows less than the cutoff value
 filter(xerror < xcutoff) |>
 # use slice to keep the first row
 slice(1) |>
 # save the cp value
 pull(CP) ->
 prune_cp

c("xcutoff" = xcutoff,
 "CP Prune" = prune_cp) |>
 round(digits = 4)
```

Now that we have our prune cutoff lets prune the full tree and visualize the results.
```{r}
# Prune the tree
prune(tree = airbnb_full,
     cp = prune_cp) ->
 airbnb_tree

# Create visual plot of the pruned tree
rpart.plot(airbnb_tree, 
          digits = 4,
          fallen.leaves = TRUE,
          type = 5,
          box.palette = 'BlGnYl',
          shadow.col = 'gray')
```

The regression tree shows that the variable of importance seems to be the number of bedrooms, with a split at 2 bedrooms. For smaller properties with less than 2 bedrooms, room type and bathrooms are key factors, with fewer bathrooms generally leading to lower prices, as shown by nodes values around 1.8 to 2.2 (log10_prices). For larger properties with greater than or equal to 2 bedrooms, it seems higher bathroom counts are linked to higher prices, reaching values as high as 2.61 for specific combinations of room type and bathroom count. Overall, the highest prices are associated with properties with more bedrooms, bathrooms and the type of room(s) while the lowest prices are found in properties with fewer amenities of variables.

```{r}
# generate predictions for the original listings dataset
predict(
 object = airbnb_tree
) ->
 pred_price

# compare the distribution of predicted vs. actual
bind_rows(
 "predicted" = summary(pred_price),
 "actual" = summary(listings_clean3$log10_price),
 .id = "price"
)

# Look at the correlation of outcomes with predictions
listings_clean3 |>
 mutate(pred_price = pred_price) |>
 summarize(
   "R2" = cor(pred_price, log10_price)^2,
   "MAE" = mean(abs(pred_price - log10_price)),
   "MAE_mean" = mean(abs(log10_price - mean(log10_price)))
 ) |>
 mutate(mae_reduc = 1 - MAE/MAE_mean)
```

From our fit staistics we can see that the regression tree has captured %51.46 of variance from the data which is a little better than the linear model from %42.3, this still indicates our predictions deviate by about 0.1461 on the log10 scale from actual prices, showing a mean reduction in error of 32.56% compared to baseline predictions, with these improvements in mind we should use a regression tree model rather than linear regression. 

Finally let's look at the actual vs predictions results of the regression tree of airbnb prices together.

```{r}
# confidence intervals for residual plotting
ci_results <- listings_clean3 |>
  mutate(
    predicted = pred_price,
    # get the nodes from the pruned tree
    node = as.numeric(row.names(airbnb_tree$frame)[airbnb_tree$where])
  ) |>
  # calculate 95% confidence intervals 
  summarise(
    mean_predicted = mean(predicted),
    mean_actual = mean(log10_price),
    se_actual = sd(log10_price) / sqrt(n()),
    lower_ci = mean_actual - 1.96 * se_actual,
    upper_ci = mean_actual + 1.96 * se_actual,
    residuals = mean_actual - mean_predicted,
    .by = 'node'
  )

# create a heat map to visualize regression tree predictions
ggplot(data = ci_results, 
       aes(x = factor(node), y = mean_actual)) +
  # Add jitter points for actual log10_price values
  geom_jitter(
    data = listings_clean3 |> 
      mutate(
        node = as.numeric(row.names(airbnb_tree$frame)[airbnb_tree$where])
      ),
    aes(
      x = factor(node), 
      y = log10_price
    ),
    color = "purple",
    alpha = 0.2,  # Make points semi-transparent
    width = 0.2,  # Add slight horizontal jitter
    inherit.aes = FALSE  # Prevent aesthetics inheritance
  ) +
  # Add tiles to represent residuals
  geom_tile(
    aes(fill = residuals),  # Residuals as fill
    color = "white",
    width = 0.9,
    height = 0.3
  ) +
  # Add error bars for confidence intervals
  geom_errorbar(
    aes(ymin = lower_ci, ymax = upper_ci),
    color = "black",
    width = 0.2,
    linetype = "dashed"
  ) +
  # Adjust the fill gradient for residuals
  scale_fill_gradient2(
    low = "blue", 
    mid = "purple", 
    high = "red", 
    midpoint = 0,
    name = "Residuals",
    breaks = c(-0.5, 0, 0.5),  # Logical breakpoints for residuals
    labels = c("Underpredict", "Accurate", "Overpredict")  # Custom labels
  ) +
  # Customize labels and theme
  labs(
    title = "Heatmap of Residuals by Node",
    subtitle = "95% confidence intervals with jittered actual prices",
    x = "Node",
    y = ""
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9)
  )

```
The residual heatmap of the regression tree predicts Airbnb prices based on our predictor variables. Taking a look at node 26 (listings with more than 2 bedrooms, fewer than 1.75 bathrooms, and classified as a private/shared rooms) demonstrates significant overprediction, likely inflated by luxury listings, suggesting the model struggles with high-priced variability in this category. In contrast, node 59 (listings with more than 3.25 bathrooms, 2.25 bedrooms, and is a private/shared rooms) shows underprediction, where actual prices exceed predictions, indicating the model undervalues premium listings. Nodes like 25 (more than 2 bedrooms and fewer than 1.75 bathrooms) align more closely with actual prices, reflecting better reliability in mid-range listings.


## Conclusions
Our analysis of Airbnb listings data reveals that several factors can influence the price of a listing, including the number of bedrooms, bathrooms and room type. ***Using machine learning methods, we were able to capture approximately 51.46% of the variability in Airbnb listing prices. This indicates that our models performed better than simply predicting the mean price for all listings. The three variables we selected: bedrooms, room type, and bathrooms account for about half of the observed variation in listing prices, suggesting that while these factors are important, other variables such as accommodations have a significant role in determining price.*** However, it is also important to note that as AirBnb mentions on their website, despite AirBnb fares, the final price comes down to the property owner's decision.

# Limitations
When interpreting the results of our analysis, it is important to acknowledge several limitations that may have impacted the accuracy and generalizability of the findings. First of all, the presence of many outliers, even after removing extreme cases, likely impacted the model's ability to accurately predict prices. This is especially true for high-end properties. It would be interesting to find out if these are real postings or are just scams. Additionally, multicollinearity among certain predictors like bedrooms, bathrooms and beds could complicate the interpretation of individual variables importance. While VIF indicated low severity, residual trends suggest room for improvement. Another limitation to consider are the models accuracy. ***kNN regression had limited performance using 2 out of the 3 predictor values, and the choice of k being relatively low compared, due to the computational cost of running the algorithm on such a set of data.*** The regression tree provided interpretability, but it only explained around 51.46% of the variance in prices. It is also important to take into account that different types of listings were grouped based on similarity in price, since there were limited listings for "shared rooms" and "hotel rooms" compared to the others. On the other hand, this dataset is specific to Los Angeles AirBnb listings and may not be generalizable to other cities with different dynamics. ***Our dataset only represents listings during a specific time period, and pricing patterns may vary significantly across different cities, seasons, and market conditions. The model's used to predict prices within this data set may perform differently in cities that are not Los Angeles with different housing markets, tourist patterns, and even local regulations affecting listing prices***. 